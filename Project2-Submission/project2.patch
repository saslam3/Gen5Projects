diff -ruN gem5_clean/src/cpu/pred/BranchPredictor.py gem5/src/cpu/pred/BranchPredictor.py
--- gem5_clean/src/cpu/pred/BranchPredictor.py	2023-03-27 01:11:26.907199975 +0000
+++ gem5/src/cpu/pred/BranchPredictor.py	2023-03-27 00:36:41.310669319 +0000
@@ -749,3 +749,11 @@
     tage = MPP_TAGE_8KB()
     loop_predictor = MPP_LoopPredictor_8KB()
     statistical_corrector = MPP_StatisticalCorrector_8KB()
+
+class GSelectBP(BranchPredictor):
+    type = 'GSelectBP'
+    cxx_class = 'GSelectBP'
+    cxx_header = "cpu/pred/gselect.hh"
+    PredictorSize = Param.Unsigned(4096, "Size of predictor (entries).")
+    PHTCtrBits = Param.Unsigned(2, "Bits per counter.")
+    globalHistoryBits = Param.Unsigned(4, "Bits of the global history.")
\ No newline at end of file
diff -ruN gem5_clean/src/cpu/pred/SConscript gem5/src/cpu/pred/SConscript
--- gem5_clean/src/cpu/pred/SConscript	2023-03-27 01:11:26.939203174 +0000
+++ gem5/src/cpu/pred/SConscript	2023-03-23 23:32:16.942950572 +0000
@@ -61,3 +61,6 @@
 DebugFlag('Tage')
 DebugFlag('LTage')
 DebugFlag('TageSCL')
+Source('gselect.cc')
+DebugFlag('Mispredict')
+DebugFlag('GSDebug')
\ No newline at end of file
diff -ruN gem5_clean/src/cpu/pred/gselect.cc gem5/src/cpu/pred/gselect.cc
--- gem5_clean/src/cpu/pred/gselect.cc	1970-01-01 00:00:00.000000000 +0000
+++ gem5/src/cpu/pred/gselect.cc	2023-03-26 22:56:20.416643296 +0000
@@ -0,0 +1,102 @@
+#include "cpu/pred/gselect.hh"
+
+#include "base/bitfield.hh"
+#include "base/intmath.hh"
+
+GSelectBP::GSelectBP(const GSelectBPParams &params)
+    : BPredUnit(params),
+      globalHistoryReg(params.numThreads, 0),
+      globalHistoryBits(ceilLog2(params.PredictorSize)),
+      globalPredictorSize(params.PredictorSize),
+      globalCtrBits(params.PHTCtrBits),
+      counters(globalPredictorSize, SatCounter8(globalCtrBits))
+{
+    if (!isPowerOf2(globalPredictorSize))
+        fatal("Invalid global history predictor size.\n");
+
+    historyRegisterMask = mask(globalHistoryBits);
+    globalHistoryMask = globalPredictorSize - 1;
+
+    threshold = (ULL(1) << (globalCtrBits - 1)) - 1;
+}
+
+void
+GSelectBP::uncondBranch(ThreadID tid, Addr pc, void * &bpHistory)
+{
+    BPHistory *history = new BPHistory;
+    history->globalHistoryReg = globalHistoryReg[tid];
+    history->finalPred = true;
+    bpHistory = static_cast<void*>(history);
+    updateGlobalHistReg(tid, true);
+}
+
+void
+GSelectBP::squash(ThreadID tid, void *bpHistory)
+{
+    BPHistory *history = static_cast<BPHistory*>(bpHistory);
+    globalHistoryReg[tid] = history->globalHistoryReg;
+
+    delete history;
+}
+
+bool
+GSelectBP::lookup(ThreadID tid, Addr branchAddr, void * &bpHistory)
+{
+    unsigned globalHistoryIdx = (((branchAddr >> instShiftAmt)
+                                ^ (globalHistoryReg[tid] << globalHistoryBits))
+                                & globalHistoryMask);
+
+    assert(globalHistoryIdx < globalPredictorSize);
+
+    bool finalPrediction = counters[globalHistoryIdx] > threshold;
+
+    BPHistory *history = new BPHistory;
+    history->globalHistoryReg = globalHistoryReg[tid];
+    history->finalPred = finalPrediction;
+    bpHistory = static_cast<void*>(history);
+    updateGlobalHistReg(tid, finalPrediction);
+
+    return finalPrediction;
+}
+
+void
+GSelectBP::btbUpdate(ThreadID tid, Addr branchAddr, void * &bpHistory)
+{
+    globalHistoryReg[tid] &= (historyRegisterMask & ~ULL(1));
+}
+
+void
+GSelectBP::update(ThreadID tid, Addr branchAddr, bool taken, void *bpHistory,
+                 bool squashed, const StaticInstPtr & inst, Addr corrTarget)
+{
+    assert(bpHistory);
+
+    BPHistory *history = static_cast<BPHistory*>(bpHistory);
+
+    if (squashed) {
+        globalHistoryReg[tid] = (history->globalHistoryReg << 1) | taken;
+        return;
+    }
+
+    unsigned globalHistoryIdx = (((branchAddr >> instShiftAmt)
+                                ^ (history->globalHistoryReg << globalHistoryBits))
+                                & globalHistoryMask);
+
+    assert(globalHistoryIdx < globalPredictorSize);
+
+    if (taken) {
+        counters[globalHistoryIdx]++;
+    } else {
+        counters[globalHistoryIdx]--;
+    }
+
+    delete history;
+}
+
+void
+GSelectBP::updateGlobalHistReg(ThreadID tid, bool taken)
+{
+    globalHistoryReg[tid] = taken ? (globalHistoryReg[tid] << 1) | 1 :
+                               (globalHistoryReg[tid] << 1);
+    globalHistoryReg[tid] &= historyRegisterMask;
+}
\ No newline at end of file
diff -ruN gem5_clean/src/cpu/pred/gselect.hh gem5/src/cpu/pred/gselect.hh
--- gem5_clean/src/cpu/pred/gselect.hh	1970-01-01 00:00:00.000000000 +0000
+++ gem5/src/cpu/pred/gselect.hh	2023-03-26 22:08:31.985830866 +0000
@@ -0,0 +1,42 @@
+#ifndef __CPU_PRED_GSELECT_PRED_HH__
+#define __CPU_PRED_GSELECT_PRED_HH__
+
+#include "base/sat_counter.hh"
+#include "cpu/pred/bpred_unit.hh"
+#include "params/GSelectBP.hh"
+
+class GSelectBP : public BPredUnit
+{
+  public:
+    GSelectBP(const GSelectBPParams &params);
+    void uncondBranch(ThreadID tid, Addr pc, void * &bp_history);
+    void squash(ThreadID tid, void *bp_history);
+    bool lookup(ThreadID tid, Addr branch_addr, void * &bp_history);
+    void btbUpdate(ThreadID tid, Addr branch_addr, void * &bp_history);
+    void update(ThreadID tid, Addr branch_addr, bool taken, void *bp_history,
+                bool squashed, const StaticInstPtr & inst, Addr corrTarget);
+
+  private:
+    void updateGlobalHistReg(ThreadID tid, bool taken);
+
+    struct BPHistory {
+        unsigned globalHistoryReg;
+        // the final taken/not-taken prediction
+        // true: predict taken
+        // false: predict not-taken
+        bool finalPred;
+    };
+
+    std::vector<unsigned> globalHistoryReg;
+    unsigned globalHistoryBits;
+    unsigned historyRegisterMask;
+
+    unsigned globalPredictorSize;
+    unsigned globalCtrBits;
+    unsigned globalHistoryMask;
+
+    std::vector<SatCounter8> counters;
+    unsigned threshold;
+};
+
+#endif // __CPU_PRED_GSELECT_PRED_HH__
\ No newline at end of file
